#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "fastapi",
#   "uvicorn",
#   "sqlalchemy",
#   "python-dotenv",
#   "psycopg2-binary",
#   "pydantic"
# ]
# ///
"""
Middleware FastAPI to connect applications to the remote Postgres DB

Run:
  uv run uvicorn app:app --reload --port 8000
or:
  uvicorn app:app --reload --port 8000

Env:
  DATABASE_URL=postgresql+psycopg2://USER:PASSWORD@HOST:PORT/DBNAME
"""
import os
import uuid
from typing import Optional, List, Dict, Any

from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, Field
from sqlalchemy import create_engine, text

#load_dotenv()
DB_URL = os.environ.get("DATABASE_URL")
if not DB_URL:
    raise RuntimeError("DATABASE_URL manquant (.env).")

engine = create_engine(DB_URL, pool_pre_ping=True)

app = FastAPI(title="VLM Eval API", version="0.1.0")


# -----------------------
# Pydantic models
# -----------------------
class CampaignOut(BaseModel):
    id: str
    campaign_name: str
    campaign_type: str
    status: Optional[str] = None


class CaseUpsertIn(BaseModel):
    # case_id is optional: if not provided for a new case, API will generate it.
    # If provided, it will be used (e.g., for pre-existing IDs).
    case_id: Optional[str] = Field(None, description="Optional UUID for the case. If not provided for a new case, one will be generated by the API.")
    case_name: str
    doc_type: Optional[str] = None
    doc_id: Optional[str] = None  # ppn
    page_no: Optional[int] = None
    year: Optional[int] = None
    language: Optional[str] = None
    source_ref: Optional[str] = None
    image_uri: Optional[str] = None
    image_sha256: Optional[str] = None
    notes: Optional[str] = None


class CaseOut(BaseModel):
    case_id: str
    case_name: str
    doc_type: Optional[str] = None
    doc_id: Optional[str] = None
    page_no: Optional[int] = None
    year: Optional[int] = None
    language: Optional[str] = None
    source_ref: Optional[str] = None
    image_uri: Optional[str] = None
    image_sha256: Optional[str] = None
    notes: Optional[str] = None


class BlockTypeOut(BaseModel):
    block_type_id: str
    code: str
    label: str


class LayoutAnnotationIn(BaseModel):
    campaign_id: str
    case_id: str
    block_code: str  # ex: title, author, jury
    x1: int
    y1: int
    x2: int
    y2: int
    source: str = "manual"
    confidence: Optional[float] = None
    annotator: Optional[str] = None
    notes: Optional[str] = None


class LayoutAnnotationOut(BaseModel):
    layout_annotation_id: str
    campaign_id: str
    case_id: str
    block_code: str
    x1: int
    y1: int
    x2: int
    y2: int
    source: str
    confidence: Optional[float] = None
    annotator: Optional[str] = None
    notes: Optional[str] = None


# -----------------------
# Helpers
# -----------------------
def q_all(sql: str, params: Dict[str, Any] | None = None):
    with engine.begin() as conn:
        return conn.execute(text(sql), params or {}).mappings().all()


def q_one(sql: str, params: Dict[str, Any] | None = None):
    with engine.begin() as conn:
        row = conn.execute(text(sql), params or {}).mappings().first()
    return row


# -----------------------
# Routes
# -----------------------
@app.get("/health")
def health():
    row = q_one("SELECT 1 AS ok;")
    return {"ok": bool(row and row["ok"] == 1)}


@app.get("/campaigns", response_model=List[CampaignOut])
def list_campaigns():
    rows = q_all("""
        SELECT campaign_id::text AS id, campaign_name, campaign_type, status
        FROM vlm_eval.campaigns
        ORDER BY created_at DESC
    """)
    return rows


@app.get("/cases", response_model=List[CaseOut])
def list_cases(
    doc_type: Optional[str] = Query(default=None),
    doc_id: Optional[str] = Query(default=None),
    limit: int = Query(default=200, ge=1, le=2000),
):
    where = []
    params: Dict[str, Any] = {"limit": limit}
    if doc_type:
        where.append("doc_type = :doc_type")
        params["doc_type"] = doc_type
    if doc_id:
        where.append("doc_id = :doc_id")
        params["doc_id"] = doc_id

    where_sql = ("WHERE " + " AND ".join(where)) if where else ""
    rows = q_all(f"""
        SELECT
          case_id::text AS case_id,
          case_name, doc_type, doc_id, page_no::int AS page_no,
          year, language, source_ref, image_uri, image_sha256, notes
        FROM vlm_eval.cases
        {where_sql}
        ORDER BY created_at DESC
        LIMIT :limit
    """, params)
    return rows


@app.post("/cases/upsert", response_model=str)
def upsert_case(payload: CaseUpsertIn):
    params = payload.model_dump()

    # If case_id is not provided in payload, generate one for new cases.
    # If case_name already exists, we retrieve its existing case_id.
    if params["case_id"] is None:
        existing_case = q_one("SELECT case_id::text FROM vlm_eval.cases WHERE case_name = :case_name", {"case_name": params["case_name"]})
        if existing_case:
            params["case_id"] = existing_case["case_id"]
        else:
            params["case_id"] = str(uuid.uuid4())

    sql = """
    INSERT INTO vlm_eval.cases (
      case_id, case_name, doc_type, doc_id, page_no, year, language,
      source_ref, image_uri, image_sha256, notes
    ) VALUES (
      CAST(:case_id AS uuid), :case_name, :doc_type, :doc_id, :page_no, :year, :language,
      :source_ref, :image_uri, :image_sha256, :notes
    )
    ON CONFLICT (case_name) DO UPDATE SET
      doc_type    = COALESCE(EXCLUDED.doc_type, vlm_eval.cases.doc_type),
      doc_id      = COALESCE(EXCLUDED.doc_id,   vlm_eval.cases.doc_id),
      page_no     = COALESCE(EXCLUDED.page_no,  vlm_eval.cases.page_no),
      year        = COALESCE(EXCLUDED.year,     vlm_eval.cases.year),
      language    = COALESCE(EXCLUDED.language, vlm_eval.cases.language),
      source_ref  = COALESCE(EXCLUDED.source_ref, vlm_eval.cases.source_ref),
      image_uri   = COALESCE(EXCLUDED.image_uri,  vlm_eval.cases.image_uri),
      image_sha256= COALESCE(vlm_eval.cases.image_sha256, EXCLUDED.image_sha256),
      notes       = COALESCE(EXCLUDED.notes, vlm_eval.cases.notes)
    RETURNING case_id::text;
    """
    with engine.begin() as conn:
        case_id = conn.execute(text(sql), params).scalar_one()
    return case_id


@app.get("/block-types", response_model=List[BlockTypeOut])
def list_block_types():
    rows = q_all("""
      SELECT block_type_id::text AS block_type_id, code, label
      FROM vlm_eval.block_types
      ORDER BY code
    """)
    return rows


@app.post("/layout-annotations", response_model=str)
def create_layout_annotation(payload: LayoutAnnotationIn):
    # resolve block_code -> block_type_id
    bt = q_one("""
      SELECT block_type_id::text AS id
      FROM vlm_eval.block_types
      WHERE code = :code
    """, {"code": payload.block_code})
    if not bt:
        raise HTTPException(status_code=400, detail=f"Unknown block_code: {payload.block_code}")

    # Generate layout_annotation_id on Python side
    layout_annotation_id = str(uuid.uuid4())

    sql = """
    INSERT INTO vlm_eval.layout_annotations (
      layout_annotation_id, campaign_id, case_id, block_type_id,
      x1, y1, x2, y2,
      source, confidence, annotator, notes
    ) VALUES (
      CAST(:layout_annotation_id AS uuid), CAST(:campaign_id as uuid), CAST(:case_id as uuid), CAST(:block_type_id as uuid),
      :x1, :y1, :x2, :y2,
      :source, :confidence, :annotator, :notes
    )
    RETURNING layout_annotation_id::text;
    """
    params = payload.model_dump()
    params["block_type_id"] = bt["id"]
    params["layout_annotation_id"] = layout_annotation_id # Add the generated UUID

    with engine.begin() as conn:
        ann_id = conn.execute(text(sql), params).scalar_one()
    return ann_id


@app.get("/layout-annotations", response_model=List[LayoutAnnotationOut])
def list_layout_annotations(
    campaign_id: str = Query(...),
    case_id: Optional[str] = Query(default=None),
):
    where = ["la.campaign_id = CAST(:campaign_id as uuid)"]
    params: Dict[str, Any] = {"campaign_id": campaign_id}
    if case_id:
        where.append("la.case_id = CAST(:case_id as uuid)")
        params["case_id"] = case_id

    rows = q_all(f"""
      SELECT
        la.layout_annotation_id::text AS layout_annotation_id,
        la.campaign_id::text AS campaign_id,
        la.case_id::text AS case_id,
        bt.code AS block_code,
        la.x1, la.y1, la.x2, la.y2,
        la.source, la.confidence, la.annotator, la.notes
      FROM vlm_eval.layout_annotations la
      JOIN vlm_eval.block_types bt ON bt.block_type_id = la.block_type_id
      WHERE {" AND ".join(where)}
      ORDER BY la.created_at DESC
    """, params)
    return rows